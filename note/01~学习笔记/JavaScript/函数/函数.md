## 函数
- 每个函数都是 `Funtion` 类型的实例，`Function` 也有属性和方法，跟其他引用类型一样。因为 *==函数是对象==* ，所以 *==函数名就是指向函数对象的指针==* ，而且不一定与函数本身紧密绑定。
- JS中函数 *==没有重载==* ，函数重复定义前者会被后者覆盖。

## 箭头函数 *ES6新增
- 例： `let arrowSum = (a, b) => {return a + b;};`
- 如果只有一个参数，可以不用括号。没有参数或者多个参数的情况下，才需要使用括号。
- 箭头函数可省略 `{}` ，使用 `{}` 说明包含“函数体”，可以包含多条语句，省略则只能有一行代码，且会 *==隐式==* 返回这行代码的值
	- 例：`( ) => 3;` 等同于 `function ( ) {return 3;};`  *==【隐式返回】 ==
- 箭头函数 *==不能使用==* `argumets`、`super`和`new.target`，也 *==不能用作构造函数==* ，此外也 *==没有prototype==* 属性

## 函数名
- 函数可以有多个名称，函数名为指向函数的 *==指针==*。将一个函数名对应的值赋值给另一个函数名时，两个函数名指向同一个函数，互不影响。
	- *==指针==* 理解：*==指针源自C++概念==* ，指针是一个变量，这个变量存储了一段内存地址，通过星号+变量名，可以访问到这个内存地址的实际内存，其他变量通过 &变量名，可以得到变量的地址。
	 - ![[C++代码.png|600|left]]
	- 同理，JS的变量名之间赋值行为 *==没有进行函数复制==* ，其实是将函数内存地址进行赋值。可以理解为是一种共享函数的行为。
		- *==ES6==* 的所有函数对象都会暴露一个指读的name属性，其中包含关于函数的信息。
		       
## 参数
- ### 参数理解
	- ECMAScript函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。
	- 在使用 `function` ( *==非箭头函数==* )定义函数时，可以在函数内部访问 `argument` 对象，从函数中取得每个传进来的参数值。
	- 可以通过 `argument[]` 的语法访问其中的元素，可以通过 `argument.length` 确定传进来多少个参数， `argument[]` 可以跟命名参数一起使用。
	- *==【TIPS】==* JS中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。
- ### 默认参数
	- ECMAScript5.1及以前，实现默认参数的一种常用方式就是检测某个参数是否等于 `undefined` 。
	- ECMAScript6以后，支持显式定义默认参数，只要在函数定义中的参数后面用=就可以为参数赋一个默认值。
		- 例：`function makeKing(name = 'Henry') {}`
	- `arguments` 对象的值不反映参数的默认值。
	- 默认参数会依照 *==定义的顺序==* 进行初始化，后定义默认值的参数可以应用先定义的参数，先定义的参数不能引用后面的默认值定义，否则会出现 *==暂时性死区==* 。
- ### 拓展参数
	- *ESCMAScript6*中 拓展操作符可以将可迭代对象拆分后返回的每个值单独做为参数传入函数。
		- 例：`函数（...可迭代对象）`
- ### 收集参数
	- 可以使用拓展操作符将不同长度的独立参数组合为一个数组。收集来的参数结果会得到一个 *==Array实例==*
		- 例： `function 函数(...参数名）{}`
	- *如果有其他命名参数，收集参数只能放在最后，且只会收集命名参数以外的参数。
	- 箭头函数支持收集参数的定义方式
		- 例：`let getSum = (...values) => {return values.reduce((x, y) => x + y, 0)`

## 函数声明与表达式
- *==函数声明提升==* ：JS加载数据时会先读取函数声明，并在执行上下文中生成函数定义，函数声明会被提升到源代码树顶部。如用 `let` 或者`var` 等将函数定义包含在一个变量初始化语句中，则函数声明不会提升。
	- `Function ( ) { }` 会提升
	- `let a = function ( ) { }` 不会提升